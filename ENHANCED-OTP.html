
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Enhanced One Time Pad Encrypt/Decrypt</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    textarea { width: 100%; height: 150px; margin: 10px 0; }
    button { margin-right: 10px; padding: 10px 20px; }
    .explanation { margin-top: 40px; padding: 20px; border-top: 1px solid #ccc; }
    pre { background: #f4f4f4; padding: 10px; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>Enhanced One Time Pad Encrypt/Decrypt</h1>
  <p>
    Enter your text and a key. The key must be at least as long as the text. In this version, a random IV (initialization vector) is generated that is as long as the plaintext. For encryption, each character of the plaintext is XORed with the corresponding character of both the key and the IV. The IV (encoded in hex) is prepended to the ciphertext so that decryption is possible.
  </p>
  
  <label for="inputText">Input Text (Plaintext for encryption, hex ciphertext for decryption):</label>
  <textarea id="inputText"></textarea>
  
  <label for="keyInput">Key (must be at least as long as the text; any standard keyboard character is allowed):</label>
  <textarea id="keyInput" placeholder="Extra key characters beyond the text length will be ignored"></textarea>
  
  <div>
    <button onclick="encrypt()">Encrypt</button>
    <button onclick="decrypt()">Decrypt</button>
  </div>
  
  <label for="outputText">Output:</label>
  <textarea id="outputText" readonly></textarea>
  
  <script>
    // Generate a secure random IV with the given length (number of characters)
    function generateIV(length) {
      const ivArray = new Uint8Array(length);
      window.crypto.getRandomValues(ivArray);
      let iv = "";
      for (let i = 0; i < ivArray.length; i++) {
        iv += String.fromCharCode(ivArray[i]);
      }
      return iv;
    }
  
    // Convert a string to a hex string (4 hex digits per character)
    function toHex(str) {
      let hex = "";
      for (let i = 0; i < str.length; i++) {
        hex += str.charCodeAt(i).toString(16).padStart(4, '0');
      }
      return hex;
    }
  
    // Convert a hex string back to a string (assumes 4 hex digits per character)
    function fromHex(hexStr) {
      let str = "";
      for (let i = 0; i < hexStr.length; i += 4) {
        str += String.fromCharCode(parseInt(hexStr.substr(i, 4), 16));
      }
      return str;
    }
  
    // Validate lengths:
    // For encryption: key must be at least as long as the plaintext.
    // For decryption: the ciphertext must be a multiple of 8 hex digits.
    // Since the encryption outputs IV and message (each character converted to 4 hex digits),
    // the total ciphertext length is 8 * (plaintext length).
    function validateLength(text, key, isDecrypt = false) {
      if (isDecrypt) {
        if (text.length % 8 !== 0) {
          alert("Ciphertext length must be a multiple of 8 hex digits.");
          return false;
        }
        let plaintextLength = text.length / 8;
        if (key.length < plaintextLength) {
          alert("For decryption, the key must be at least as long as the plaintext.");
          return false;
        }
      } else {
        if (text.length > key.length) {
          alert("For encryption, the key must be at least as long as the text.");
          return false;
        }
      }
      return true;
    }
  
    // Encrypt:
    // 1. Generate an IV that is exactly as long as the plaintext.
    // 2. For each character, compute:
    //    ciphertextChar = plaintextChar XOR keyChar XOR ivChar
    // 3. Convert both the IV and the ciphertext to hex (4 digits per character)
    // 4. Prepend the IV (in hex) to the ciphertext.
    function encrypt() {
      const plaintext = document.getElementById("inputText").value;
      // Remove newline characters from the key for consistency
      const rawKey = document.getElementById("keyInput").value;
      const key = rawKey.replace(/\r?\n/g, "");
      
      if (!validateLength(plaintext, key)) return;
      
      const iv = generateIV(plaintext.length);
      const ivHex = toHex(iv);
  
      let encryptedHex = "";
      for (let i = 0; i < plaintext.length; i++) {
        const plainChar = plaintext.charCodeAt(i);
        const keyChar = key.charCodeAt(i);
        const ivChar = iv.charCodeAt(i);
        const encryptedChar = plainChar ^ keyChar ^ ivChar;
        encryptedHex += encryptedChar.toString(16).padStart(4, '0');
      }
  
      // Prepend the IV (in hex) to the encrypted message.
      document.getElementById("outputText").value = ivHex + encryptedHex;
    }
  
    // Decrypt:
    // 1. Determine the plaintext length from the ciphertext.
    //    Since the ciphertext is (IV + encrypted message) and each character is 4 hex digits,
    //    the total length is 8 * (plaintext length). Thus, plaintextLength = ciphertext.length / 8.
    // 2. Extract the IV from the beginning of the ciphertext.
    // 3. Use the IV and the key to XOR-decrypt the rest of the ciphertext.
    function decrypt() {
      const inputText = document.getElementById("inputText").value;
      // Remove newline characters from the key for consistency
      const rawKey = document.getElementById("keyInput").value;
      const key = rawKey.replace(/\r?\n/g, "");
      
      if (!validateLength(inputText, key, true)) return;
      
      // Determine plaintext length from ciphertext.
      let plaintextLength = inputText.length / 8;
  
      // IV is the first plaintextLength characters (hex-encoded, so 4 digits per char)
      let ivHexLength = plaintextLength * 4;
      const ivHex = inputText.substring(0, ivHexLength);
      const iv = fromHex(ivHex);
      const encryptedHex = inputText.substring(ivHexLength);
  
      let decryptedText = "";
      for (let i = 0; i < plaintextLength; i++) {
        const hexPart = encryptedHex.substr(i * 4, 4);
        const encryptedChar = parseInt(hexPart, 16);
        const keyChar = key.charCodeAt(i);
        const ivChar = iv.charCodeAt(i);
        const plainChar = encryptedChar ^ keyChar ^ ivChar;
        decryptedText += String.fromCharCode(plainChar);
      }
      document.getElementById("outputText").value = decryptedText;
    }
  </script>
  
  <div class="explanation">
    <h2>Comprehensive Explanation</h2>
    <h3>Overview of the API & Implementation</h3>
    <p>
      This web application is built using HTML5 and JavaScript. The encryption and decryption are performed entirely in the browser. Key functions include:
    </p>
    <ul>
      <li>
        <strong>window.crypto.getRandomValues:</strong> Used to generate a cryptographically secure random IV (initialization vector).
      </li>
      <li>
        <strong>XOR Operation:</strong> The core of the one time pad (OTP) method, where each character of the plaintext is XORed with the corresponding key character.
      </li>
      <li>
        <strong>Hex Encoding:</strong> Each character (after XOR) is converted to a 4-digit hexadecimal representation to support the full Unicode range.
      </li>
    </ul>
    
    <h3>One Time Pad (OTP) Method</h3>
    <p>
      A one time pad is an encryption technique that uses a key which is as long as the message. The security of an OTP is perfect (information-theoretic) when:
    </p>
    <ul>
      <li>The key is truly random.</li>
      <li>The key is at least as long as the message.</li>
      <li>The key is used only once.</li>
      <li>The key is kept completely secret.</li>
    </ul>
    <p>
      The encryption is done using the XOR operation because XOR is its own inverse; this means that applying the same operation a second time with the same key recovers the original plaintext.
    </p>
    
    <h3>Enhanced IV (Initialization Vector)</h3>
    <p>
      In a pure OTP, if the key is truly random, an IV is not necessary. However, to safeguard against accidental key reuse or situations where the plaintext and key might be similar, an IV is added as an enhancement:
    </p>
    <ul>
      <li>
        <strong>Full-Length IV:</strong> A random IV is generated that is exactly as long as the plaintext. This means each character position gets a unique random value.
      </li>
      <li>
        <strong>XOR Combination:</strong> For each character, the encryption is computed as:
        <br>
        <code>ciphertextChar = plaintextChar XOR keyChar XOR ivChar</code>
      </li>
      <li>
        The IV is generated using <code>window.crypto.getRandomValues</code>, ensuring high-quality randomness.
      </li>
      <li>
        The IV (converted to hex) is prepended to the ciphertext so that it can be used during decryption.
      </li>
    </ul>
    <p>
      This extra randomness helps ensure that even if the same plaintext and key are accidentally reused, the ciphertext will still be different each time.
    </p>
    
    <h3>Allowed Key Characters & Key Sanitization</h3>
    <p>
      The key can include any character or symbol found on a standard keyboard. In this implementation, the allowed characters are the standard printable ASCII characters. These are:
    </p>
    <pre>
 !"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
    </pre>
    <p>
      There are a total of <strong>95</strong> printable ASCII characters. However, newline characters can be introduced unintentionally due to text wrapping or different browser sizes. To ensure the key remains consistent across devices, newline characters are automatically removed.
    </p>
    
    <h3>Overall Security & Methodology</h3>
    <p>
      While this implementation demonstrates the core mathematical operation of a one time pad, perfect secrecy is only guaranteed if the key is:
    </p>
    <ul>
      <li>Truly random.</li>
      <li>At least as long as the plaintext.</li>
      <li>Used only once.</li>
      <li>Kept completely secret.</li>
    </ul>
    <p>
      The addition of the full-length IV is an enhancement to help mitigate potential human errors—such as accidentally reusing a key—by ensuring that the ciphertext is different even when the same plaintext and key are used repeatedly. However, if used properly (with a truly random key used only once), the method remains a one time pad, offering perfect secrecy.
    </p>
    
    <h3>Additional Explanation: Observing Repeating "00" Patterns</h3>
    <p>
      When both the plaintext and the key consist solely of the character "a", the encryption behaves in a predictable way. Since the ASCII code for "a" is 97, the XOR of the plaintext and key characters is <code>97 XOR 97 = 0</code>. As a result, the encryption simplifies to:
      <br>
      <code>encryptedChar = 0 XOR ivChar = ivChar</code>.
    </p>
    <p>
      This means that the ciphertext is essentially the IV itself. Each IV character is then converted into a 4-digit hexadecimal string. Smaller values (like 0) are padded with leading zeros (e.g., 0 becomes <code>"0000"</code>), which is why you see consistent "00" patterns in the output.
    </p>
    
    <h3>Key Sanitization: Removing Newline Characters</h3>
    <p>
      Newline characters in the key can be inadvertently introduced by browsers with smaller windows or due to soft/hard wrapping in textareas. Since newlines might differ between devices, they could alter the intended key value. To ensure consistency, newline characters are removed from the key before encryption and decryption. This avoids any unintended key modifications and guarantees that the same key is used regardless of browser or device.
    </p>
    
    <h3>Summary</h3>
    <p>
      This enhanced one time pad encryptor/decryptor:
    </p>
    <ul>
      <li>Uses HTML5 and JavaScript, leveraging the browser’s secure crypto API.</li>
      <li>Encrypts by XORing each character of the plaintext with the corresponding key character and a full-length random IV.</li>
      <li>Outputs a hex-encoded ciphertext (with 4 hex digits per character) where the IV is prepended to the encrypted message.</li>
      <li>Supports any standard keyboard characters for the key – a total of 95 printable ASCII characters.</li>
      <li>Automatically removes newline characters from the key to ensure consistent behavior across different browsers and devices.</li>
      <li>Remains a one time pad (and thus perfectly secure) when the key is truly random, used only once, and kept secret, with the IV acting as an extra safeguard.</li>
    </ul>
  </div>
</body>
</html>

