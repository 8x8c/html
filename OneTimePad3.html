
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>One Time Pad Encrypt/Decrypt with Full-Length IV</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    textarea { width: 100%; height: 150px; margin: 10px 0; }
    button { margin-right: 10px; padding: 10px 20px; }
    .explanation { margin-top: 40px; padding: 20px; border-top: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>One Time Pad Encrypt/Decrypt with Full-Length IV</h1>
  <p>
    Enter your text and a key. The key must be at least as long as the text. In this version, the IV is generated to be as long as the plaintext so that each character is combined with a unique random value. For encryption, the plaintext is XORed with both the key and a full-length random IV, and the output is a hex-encoded ciphertext (using 4 hex digits per character). The IV (encoded in hex) is prepended to the ciphertext so that decryption is possible.
  </p>
  
  <label for="inputText">Input Text (Plaintext for encryption, hex ciphertext for decryption):</label>
  <textarea id="inputText"></textarea>
  
  <label for="keyInput">Key (must be at least as long as the text; any standard keyboard character is allowed):</label>
  <textarea id="keyInput" placeholder="Extra key characters beyond the text length will be ignored"></textarea>
  
  <div>
    <button onclick="encrypt()">Encrypt</button>
    <button onclick="decrypt()">Decrypt</button>
  </div>
  
  <label for="outputText">Output:</label>
  <textarea id="outputText" readonly></textarea>
  
  <script>
    // Generate a secure random IV with a given length (number of characters)
    function generateIV(length) {
      const ivArray = new Uint8Array(length);
      window.crypto.getRandomValues(ivArray);
      let iv = "";
      for (let i = 0; i < ivArray.length; i++) {
        iv += String.fromCharCode(ivArray[i]);
      }
      return iv;
    }

    // Convert a string into a hex string (4 hex digits per character)
    function toHex(str) {
      let hex = "";
      for (let i = 0; i < str.length; i++) {
        hex += str.charCodeAt(i).toString(16).padStart(4, '0');
      }
      return hex;
    }

    // Convert a hex string back to a normal string (assumes 4 hex digits per character)
    function fromHex(hexStr) {
      let str = "";
      for (let i = 0; i < hexStr.length; i += 4) {
        str += String.fromCharCode(parseInt(hexStr.substr(i, 4), 16));
      }
      return str;
    }

    // Validate lengths:
    // - For encryption: key must be at least as long as the plaintext.
    // - For decryption: the ciphertext hex must have a total length that is divisible by 8,
    //   because the first half is the IV and the second half is the encrypted message.
    function validateLength(text, key, isDecrypt = false) {
      if (isDecrypt) {
        if (text.length % 8 !== 0) {
          alert("For decryption, the total ciphertext length (IV + message) must be a multiple of 8 hex digits.");
          return false;
        }
        let n = text.length / 8; // plaintext length (and IV length)
        if (key.length < n) {
          alert("For decryption, the key must be at least as long as the plaintext (derived from ciphertext length).");
          return false;
        }
      } else {
        if (text.length > key.length) {
          alert("For encryption, the key must be at least as long as the text.");
          return false;
        }
      }
      return true;
    }

    // Encrypt: generate an IV that is exactly as long as the plaintext.
    // For each character: encryptedChar = plaintextChar XOR keyChar XOR ivChar.
    // Output = IV (in hex) concatenated with encrypted message (in hex).
    function encrypt() {
      const plaintext = document.getElementById("inputText").value;
      const key = document.getElementById("keyInput").value;
      
      if (!validateLength(plaintext, key)) return;
      
      const iv = generateIV(plaintext.length);
      const ivHex = toHex(iv);
      
      let encryptedHex = "";
      for (let i = 0; i < plaintext.length; i++) {
        let plainChar = plaintext.charCodeAt(i);
        let keyChar = key.charCodeAt(i);
        let ivChar = iv.charCodeAt(i);
        let encryptedChar = plainChar ^ keyChar ^ ivChar;
        encryptedHex += encryptedChar.toString(16).padStart(4, '0');
      }
      
      // Prepend the IV (in hex) to the encrypted message.
      document.getElementById("outputText").value = ivHex + encryptedHex;
    }

    // Decrypt: extract the full-length IV and then decrypt the remaining ciphertext.
    function decrypt() {
      const inputText = document.getElementById("inputText").value;
      const key = document.getElementById("keyInput").value;
      
      if (!validateLength(inputText, key, true)) return;
      
      let n = inputText.length / 8; // n = plaintext length (and IV length)
      const ivHex = inputText.substring(0, n * 4);
      const iv = fromHex(ivHex);
      const encryptedHex = inputText.substring(n * 4);
      
      let decryptedText = "";
      for (let i = 0; i < n; i++) {
        let hexPart = encryptedHex.substr(i * 4, 4);
        let encryptedChar = parseInt(hexPart, 16);
        let keyChar = key.charCodeAt(i);
        let ivChar = iv.charCodeAt(i);
        let plainChar = encryptedChar ^ keyChar ^ ivChar;
        decryptedText += String.fromCharCode(plainChar);
      }
      document.getElementById("outputText").value = decryptedText;
    }
  </script>
  
  <div class="explanation">
    <h2>What is a One Time Pad?</h2>
    <p>
      A one time pad is an encryption technique that uses a key that is as long as the message itself. The method works by combining each character of the plaintext with a corresponding character from the key using a reversible operation—in this case, the XOR (exclusive OR) operation.
    </p>
    <p>
      For a one time pad to be considered truly secure, the following conditions must be met:
    </p>
    <ul>
      <li><strong>Truly Random Key:</strong> The key must be generated in a truly random manner.</li>
      <li><strong>Key Length:</strong> The key must be at least as long as the plaintext. Extra key characters are ignored.</li>
      <li><strong>Single Use:</strong> Each key must be used only once and then discarded.</li>
      <li><strong>Secrecy:</strong> The key must be kept completely secret between the communicating parties.</li>
      <li><strong>Allowed Characters:</strong> The key can include any character or symbol found on a standard keyboard.</li>
      <li><strong>Case Sensitivity:</strong> The encryption is case sensitive, meaning uppercase and lowercase letters are treated as distinct.</li>
    </ul>
    <p>
      <strong>Enhancement with a Full-Length IV:</strong> In our implementation we add an IV (initialization vector) to introduce randomness so that even if the same plaintext and key are used more than once, the ciphertext will be different. Unlike a fixed, repeating IV, here the IV is generated to be as long as the plaintext. This is considered the best approach in this context because it ensures that every character is XORed with a unique random value – there is no cyclic repetition of the IV. The IV is generated using the browser’s cryptographically secure API, ensuring high-quality randomness.
    </p>
    <p>
      <em>Note:</em> In a true one time pad, if the key is perfectly random, kept secret, and used only once, perfect secrecy is already achieved. The addition of an IV in this implementation primarily guards against accidental key reuse or scenarios where similar plaintexts and keys might be used. It does not fundamentally change the security of a proper one time pad, but it does improve the unpredictability of the ciphertext output in practical applications.
    </p>
    <p>
      In summary, using an IV that is as long as the plaintext avoids any repetition and maximizes randomness. However, the overall security of a one time pad relies on having a truly random key that is never reused.
    </p>
  </div>
</body>
</html>


